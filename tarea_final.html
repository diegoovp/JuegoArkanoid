<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Arkanoid - Zoom</title>
  <style>
    body {
      background: linear-gradient(to bottom, #A0C4FF, #FF7E5F); /* Gradiente de azul suave a naranja */
      margin: 0;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    canvas {
      display: block;
      border: 2px solid #fff;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="1000" height="900"></canvas>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    // Imágenes
    const background = new Image();
    const brickImage = new Image();
    const ballImage = new Image();
    const paddleImage = new Image();
    
    background.src = "fondo.jpg";  // Mantener el fondo original
    brickImage.src = "ladrillo.jpg"; 
    ballImage.src = "pelota.jpg";    
    paddleImage.src = "nube.png";   

    // Pelota
    let x = canvas.width / 2;
    let y = canvas.height - 50;
    let dx = 0.5;
    let dy = -0.5;
    const ballRadius = 25;

    // Pala (nube)
    const paddleHeight = 50;
    const paddleWidth = 200;
    let paddleX = (canvas.width - paddleWidth) / 2;
    let rightPressed = false;
    let leftPressed = false;

    // Ladrillos
    let brickRowCount = 2;  // 2 filas de ladrillos
    const brickColumnCount = 7;  // 7 columnas de ladrillos
    const brickWidth = 120;
    const brickHeight = 50;
    const brickPadding = 15;
    const brickOffsetTop = 40;
    const brickOffsetLeft = 50;
    const bricks = [];

    function createBricks() {
      bricks.length = 0;  // Limpiar los ladrillos anteriores
      for (let c = 0; c < brickColumnCount; c++) {
        bricks[c] = [];
        for (let r = 0; r < brickRowCount; r++) {
          bricks[c][r] = { x: 0, y: 0, status: 1 };
        }
      }
    }

    createBricks();  // Llamamos a la función para crear los ladrillos iniciales

    // Inicializar puntuación y nivel
    let score = 0;
    let level = 1;
    let lastScoreForLevelUp = 0;

    document.addEventListener("keydown", keyDownHandler);
    document.addEventListener("keyup", keyUpHandler);

    let imagesLoaded = false;
    background.onload = brickImage.onload = ballImage.onload = paddleImage.onload = function() {
      imagesLoaded = true;
      draw();  // Empezamos el juego una vez que todas las imágenes están cargadas
    };

    function keyDownHandler(e) {
      if (e.key === "Right" || e.key === "ArrowRight") rightPressed = true;
      else if (e.key === "Left" || e.key === "ArrowLeft") leftPressed = true;
    }

    function keyUpHandler(e) {
      if (e.key === "Right" || e.key === "ArrowRight") rightPressed = false;
      else if (e.key === "Left" || e.key === "ArrowLeft") leftPressed = false;
    }

    function drawBall() {
      ctx.drawImage(ballImage, x - ballRadius, y - ballRadius, ballRadius * 2, ballRadius * 2);
    }

    function drawPaddle() {
      ctx.drawImage(paddleImage, paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
    }

    function drawScore() {
      ctx.font = "20px Arial";
      ctx.fillStyle = "#fff";
      ctx.fillText("Puntos: " + score, 8, 30);
    }

    function drawLevel() {
      ctx.font = "20px Arial";
      ctx.fillStyle = "#fff";
      ctx.fillText("Nivel: " + level, canvas.width - 100, 30);
    }

    function drawBricks() {
      for (let c = 0; c < brickColumnCount; c++) {
        for (let r = 0; r < brickRowCount; r++) {
          const b = bricks[c][r];
          if (b.status === 1) {
            const brickX = (c * (brickWidth + brickPadding)) + brickOffsetLeft;
            const brickY = (r * (brickHeight + brickPadding)) + brickOffsetTop;
            b.x = brickX;
            b.y = brickY;

            ctx.drawImage(brickImage, brickX, brickY, brickWidth, brickHeight);
          }
        }
      }
    }

    function collisionDetection() {
      for (let c = 0; c < brickColumnCount; c++) {
        for (let r = 0; r < brickRowCount; r++) {
          const b = bricks[c][r];
          if (b.status === 1) {
            if (
              x > b.x &&
              x < b.x + brickWidth &&
              y > b.y &&
              y < b.y + brickHeight
            ) {
              dy = -dy;
              b.status = 0;
              score++;
              levelUpIfNeeded();
            }
          }
        }
      }
    }

    function levelUpIfNeeded() {
      if (score - lastScoreForLevelUp >= 10) {
        lastScoreForLevelUp = score;
        dx += dx > 0 ? 0.1 : -0.1;
        dy += dy > 0 ? 0.1 : -0.1;
      }
    }

    function drawBackground() {
      ctx.drawImage(background, 0, 0, canvas.width, canvas.height); // Mantén el fondo original
    }

    function resetGame() {
      // Restablecer puntuación y nivel
      score = 0;
      level = 1;
      brickRowCount = 2;  // 2 filas de ladrillos
      createBricks();  // Reiniciar los ladrillos
    }

    function draw() {
      if (!imagesLoaded) return;

      drawBackground();  // Usamos el fondo original de la imagen
      drawBricks();
      drawBall();
      drawPaddle();
      drawScore();
      drawLevel();
      collisionDetection();

      // Rebotes
      if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) dx = -dx;
      if (y + dy < ballRadius) dy = -dy;
      else if (y + dy > canvas.height - ballRadius) {
        if (x > paddleX && x < paddleX + paddleWidth) {
          dy = -dy;
          score++;
          levelUpIfNeeded();
        } else {
          alert("PISA EL FRENO MADALENO QUE HAS PERDIDO");
          resetGame();  // Reinicia el juego al final
        }
      }

      // Movimiento pala (nube más lento)
      if (rightPressed && paddleX < canvas.width - paddleWidth) paddleX += 2;  // Hacemos que se mueva más lento
      else if (leftPressed && paddleX > 0) paddleX -= 2;

      // Movimiento bola
      x += dx;
      y += dy;

      requestAnimationFrame(draw);  // Llamamos de nuevo a la función de dibujo
    }
  </script>
</body>
</html>
